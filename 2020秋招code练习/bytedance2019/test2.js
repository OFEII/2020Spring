var numTrees = function(n) {
    let result = 0;
    if(n == 0 || n == 1){
        return 1
    }else{
        result = arguments.callee(n-1)*(4*n-2)/(n+1)
        result = parseInt(result) % 1000000007
        return result
    }
};
console.log(numTrees(500))
// // 给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？
// /**
//  * 这道题，用动态规划
//  * 
//  * 先看n=3的情况 F(3)
//  * 
//  * 首先，以1为根节点，那么2，3只能在右边，那么1不动的话，就是求2,3两个元素的组合，就是 F(2)
//  * 然后以2为根节点，那么左边是1，右边是3，此时，只有一种情况，就是F(1)
//  * 然后以3为根节点，那么左边是1，2，右边没有，此时，3不动，就是求F(2)
//  * 
//  * 所以，有如下规律:
//  * F(3) = F(2) + F(1) + F(2)
//  * 
//  * 再看n=4的情况 F(4)
//  * 首先，以1为根节点，那么2，3,4只能在右边，那么1不动的话，就是求2,3,4两个元素的组合，就是 F(3)
//  * 然后以2为根节点，那么左边是1，右边是3,4，此时，就是求F(1)*F(2)，因为左边是1，只有一种情况，右边有两种情况，所以F(1)*F(2)=F(2)，F(1)=1
//  * 然后以3为根节点，那么左边是1，2，右边4，此时，还是求F(2)*F(1)
//  * 然后以4为根节点，那么左边是1，2，3,右边没有，此时，求 F(3)*F(0),F(0)=1
//  * 
//  * 所以：
//  * F(4) = F(0)*F(3) + F(1)*F(2) + F(2)*F(1) + F(3)*F(0)
//  * 
//  * 之前的F(3)也可以这样求：
//  * F(3) = F(0)*F(2) + F(1)*F(1) + F(2)*F(0)
//  * 
//  * 所以公式
//  * F(n) = F(0)*F(n-1) + ... + F(n-1) * F(0); 其中F(0) = F(1) = 1
//  * 
//  * @param {number} n
//  * @return {number}
//  */
// var numTrees = function (n) {
//     if (n == 1) return 1;
//     if (n == 2) return 2;
//     if (n == 3) return 5;

//     var dp = [1, 1, 2, 5];
//     var sum = 7;
//     for (var i = 4; i <= n; i++) {
//         var left = 0,
//             right = i - 1,
//             sum = 0;
//         while (left < i) {
//             sum += dp[left] * dp[right];
//             left++;
//             right--;
//         }
//         dp[i] = sum;
//     }
//     return dp[n];
// };


// var numTrees = function(n) {
//     // 0子树情况要置为1  
//     let dp=[1,1,2];
//     for(let i =3;i<=n;i++)
//         {
//             dp[i]=0;
//             for(let j=0;j<i;j++)
//                 {
//                     // 由于 一个i节点的可以分割为 左边j，右边i-j-1  因此可能的种类就是j的情况*i-j-1的情况
//                     // 其中j取值可以是0~i-1
//                     dp[i]+=(dp[j]*dp[i-j-1])
//                 }
//         }
//     return dp[n]
// };

